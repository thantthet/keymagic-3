# KeyMagic Binary Keyboard File (KM2) Format Documentation

## Overview

The KeyMagic Binary Keyboard File (KM2) format is a compiled binary representation of KeyMagic keyboard layouts. KM2 files are generated by compiling KeyMagic Script (KMS) files and are optimized for fast loading and efficient runtime processing by the KeyMagic input method engine.

## File Structure

The KM2 file consists of four main sections written sequentially:

1. **File Header** - Version info and section counts
2. **String/Variable Section** - Variable definitions and string literals
3. **Info Section** - Metadata about the keyboard layout
4. **Rules Section** - Binary-encoded keyboard mapping rules

## Data Types and Endianness

- **Endianness**: All multi-byte values are stored in **little-endian** format
- **Strings**: UTF-16LE encoding (2 bytes per character)
- **Booleans**: Single byte values (0x00 = false, 0x01 = true)
- **Integers**: 16-bit (short) and 32-bit (int) signed integers
- **File Size**: Typically ranges from a few KB to several hundred KB

## File Header

The file header is 16 bytes and contains essential file information:

```c
struct KM2Header {
    char magicCode[4];           // File signature: "KMKL" (0x4B4D4B4C)
    uint8_t majorVersion;        // Major version number (currently 1)
    uint8_t minorVersion;        // Minor version number (currently 5)
    uint16_t stringCount;        // Number of strings/variables
    uint16_t infoCount;          // Number of info entries
    uint16_t ruleCount;          // Number of mapping rules
    LayoutOptions options;       // Layout behavior flags (5 bytes)
};
```

### Layout Options Structure

```c
struct LayoutOptions {
    bool trackCaps;    // Consider CAPSLOCK key state in pattern matching
    bool autoBksp;     // Enable smart backspace behavior
    bool eat;          // Consume keys that don't match any rule
    bool posBased;     // Layout based on US keyboard physical positions
    bool rightAlt;     // Treat CTRL+ALT combination as Right Alt (v1.5+)
};
```

### Version History

| Version | Features |
|---------|----------|
| 1.3 | Basic format without info section |
| 1.4 | Added info section for metadata |
| 1.5 | Added rightAlt option in layout options |

## String/Variable Section

This section stores all variables and string constants referenced in the keyboard rules.

### Structure

Each string entry follows this format:

```
+--------+--------+--------+--------+
| Length |      UTF-16LE String     |
| 2bytes |     (Length * 2 bytes)   |
+--------+-----------------------+--+
```

- **Length** (2 bytes): Number of Unicode characters (not bytes)
- **Data** (variable): UTF-16LE encoded string data

### Variable References

Variables can contain references to other variables using the `opVARIABLE` opcode (0x00F1) followed by a 1-based index.

**Important**: All variable indices in KM2 format are **1-based**, not 0-based. This means:
- Variable index 1 refers to the first string in the strings table (index 0 in memory)
- Variable index 2 refers to the second string (index 1 in memory)
- And so on...

### Example

```
String: "ကခဂ" (3 Myanmar characters)
Binary: 0x0003 0x1000 0x1001 0x1002
        |      |              |
        Length UTF-16LE chars  |
```

## Info Section

The info section stores metadata about the keyboard layout. Available since version 1.4.

### Structure

Each info entry has this format:

```
+--------+--------+--------+--------+
|   ID   | Length |      Data       |
| 4bytes | 2bytes | (Length bytes)  |
+--------+--------+-----------------+
```

### Standard Info IDs

| ID (4 bytes) | ASCII | Description | Data Format |
|--------------|-------|-------------|-------------|
| 0x6E616D65 | 'name' | Keyboard display name | UTF-16LE string |
| 0x64657363 | 'desc' | Keyboard description | UTF-16LE string |
| 0x666F6E74 | 'font' | Recommended font family | UTF-16LE string |
| 0x69636F6E | 'icon' | Keyboard icon | BMP image data |
| 0x68746B79 | 'htky' | Hotkey combination | Binary hotkey data |

Note: The 4-byte IDs are the little-endian representation of the ASCII characters (e.g., 'name' is stored as `b"eman"`).

### Icon Data Format

Icon data is stored as a complete BMP file including headers. The icon should be 16x16 or 32x32 pixels for optimal display.

### Hotkey Data Format

Hotkey data encodes key combinations:
- **Modifier flags** (1 byte): Ctrl, Alt, Shift combinations
- **Virtual key code** (1 byte): Target key code

## Indexing Conventions

**Important**: The KM2 format uses **1-based indexing** throughout:

1. **Variable Indices**: When referencing strings in the strings table
   - Index 1 = First string (array index 0)
   - Index 2 = Second string (array index 1)
   - Index 0 = Invalid/not used

2. **Reference Indices**: When using back-references ($1, $2, etc.)
   - $1 = First captured segment
   - $2 = Second captured segment

3. **State Indices**: When referencing states
   - States are compiled to integer indices
   - Each unique state name in KMS gets assigned a sequential integer
   - State indices are 0-based integers

4. **Character Position Indices**: When using ANYOF wildcards
   - Position indices are 0-based (first character = position 0)
   - These are captured as strings and parsed when needed

## Rules Section

The rules section contains the compiled keyboard mapping rules encoded as binary opcodes.

### Rule Structure

Each rule consists of:

```
+--------+--------+--------+--------+
|LHS Len |LHS Data|RHS Len |RHS Data|
|2 bytes |Variable|2 bytes |Variable|
+--------+--------+--------+--------+
```

- **LHS (Left-Hand Side)**: Input pattern to match
- **RHS (Right-Hand Side)**: Output pattern to generate
- **Length fields**: The LHS Len and RHS Len are specified in **16-bit words (uint16_t units)**, not bytes!
  - To get the actual byte count, multiply the length value by 2
  - Example: Length value of 3 means 3 words = 6 bytes
  - This allows for efficient storage since all opcodes are 16-bit values

### Binary Opcodes

All opcodes are 2-byte values (16-bit integers):

| Opcode | Name | Description | Parameters |
|--------|------|-------------|------------|
| 0x00F0 | opSTRING | String literal | Length + UTF-16LE string |
| 0x00F1 | opVARIABLE | Variable reference | 1-based variable index |
| 0x00F2 | opREFERENCE | Back-reference | Segment number (1-based) |
| 0x00F3 | opPREDEFINED | Virtual key code | Internal predefined value (NOT Windows VK code) |
| 0x00F4 | opMODIFIER | Modifier/Index | Context-dependent: modifier flags in LHS, or index reference in RHS |
| 0x00F6 | opAND | Logical AND | Combines conditions |
| 0x00F8 | opANY | Match any character | None |
| 0x00F9 | opSWITCH | State switch | State index (integer) |

#### Important Notes on opPREDEFINED

- **opPREDEFINED values are internal enum values**, not platform-specific key codes
- In LHS: Can only appear after opAND to form virtual key combinations
- In RHS: The special value 1 (VirtualKey::Null) represents NULL output
- Examples:
  - VirtualKey::Back = 2 (NOT Windows VK_BACK 0x08)
  - VirtualKey::Space = 12 (NOT Windows VK_SPACE 0x20)
  - VirtualKey::KeyA = 26 (NOT Windows VK_A 0x41)

### Modifier Flags

The `opMODIFIER` (0x00F4) opcode uses these flag values as parameters:

| Flag | Value | Description | Usage |
|------|-------|-------------|-------|
| FLAG_ANYOF | 0x00F5 | Match any character in variable | Used in LHS pattern matching |
| FLAG_NANYOF | 0x00F7 | Match character NOT in variable | Used in LHS pattern matching |

Note: When `opMODIFIER` appears in RHS after `opVARIABLE`, its parameter represents a capture reference index for Variable[index] patterns.

### Rule Encoding Examples

#### Simple String Mapping
KMS: `"ka" => "က"`

Binary encoding:
```
LHS: opSTRING, 0x0002, 'k', 'a'
RHS: opSTRING, 0x0001, 'က'
```

#### Variable with Wildcard
KMS: `$consonants[*] => $vowels[$1]`

Binary encoding:
```
LHS: opVARIABLE, variable_index_consonants, opMODIFIER(FLAG_ANYOF)
RHS: opVARIABLE, variable_index_vowels, opREFERENCE, 0x0001
```

#### Variable with Index (Variable[reference])
KMS: `$baseK[*] => $baseU[$1]`

This pattern matches any character from `$baseK` and outputs the corresponding character from `$baseU` at the same position.

Binary encoding (assuming $baseK is variable 1 and $baseU is variable 2):
```
LHS: opVARIABLE, 0x0001, opMODIFIER(FLAG_ANYOF)  // $baseK[*]
RHS: opVARIABLE, 0x0002, opMODIFIER(0x0001)      // $baseU[$1]
```

In the RHS, `opMODIFIER` following `opVARIABLE` represents an index operation:
- The modifier value (0x0001) refers to capture reference 1 (the position matched by [*])
- The engine should:
  1. Get the capture value from reference 1 (e.g., "0" if first character matched)
  2. Parse this as a numeric index
  3. Extract the character at that position from the variable

#### Virtual Key Combination
KMS: `<VK_SHIFT & VK_KEY_A> => "အ"`

Binary encoding:
```
LHS: opAND, opPREDEFINED, VK_SHIFT, opPREDEFINED, VK_KEY_A
RHS: opSTRING, 0x0001, 'အ'
```

**Note**: For virtual key combinations, the `opAND` (0x00F6) opcode **must** appear first, followed by the sequence of `opPREDEFINED` opcodes for each key in the combination.

#### State Switch
KMS: `< VK_CFLEX > => ('zg_key')`

Binary encoding:
```
LHS: opPREDEFINED, VK_CFLEX
RHS: opSWITCH, 0x0005  // Integer index assigned to 'zg_key' state during compilation
```

Note: State names from KMS are converted to integer indices during compilation. The engine tracks active states using these integer values, not string names.

## File Loading Process

The KeyMagic engine loads KM2 files using this sequence:

1. **Header Validation**
   - Verify magic code "KMKL"
   - Check version compatibility
   - Read section counts

2. **String/Variable Loading**
   - Read `stringCount` entries
   - Store in indexed array for rule references
   - Resolve variable cross-references

3. **Info Loading** (version 1.4+)
   - Read `infoCount` metadata entries
   - Store keyboard name, description, etc.

4. **Rule Loading**
   - Read `ruleCount` binary rule entries
   - **Important**: Rule lengths are in 16-bit words, multiply by 2 for byte count
   - Convert opcodes to internal rule representation
   - Sort rules by matching priority

5. **Optimization**
   - Build lookup tables for fast pattern matching
   - Prepare state transition tables

## File Creation Process

KM2 files are created by the KeyMagic parser:

1. **Parse KMS file** using Flex/Bison parser
2. **Build symbol table** of variables and strings
3. **Compile rules** to binary opcode sequences
4. **Generate header** with counts and options
5. **Write binary file** in sequential section order

## Performance Considerations

The KM2 format is optimized for:

- **Fast loading**: Binary format loads faster than parsing text
- **Memory efficiency**: Compact representation reduces memory usage
- **Runtime speed**: Pre-compiled opcodes enable fast pattern matching
- **Rule priority**: Rules are stored in matching priority order

## Debugging and Analysis

To analyze KM2 files:

1. **Hex editors**: View raw binary structure
2. **KeyMagic tools**: Use built-in debugging functions
3. **Custom parsers**: Write tools using the format specification

## Error Handling

Common file format errors:

- **Invalid magic code**: File is not a KM2 file
- **Unsupported version**: File version too new or old
- **Truncated file**: File size doesn't match expected sections
- **Invalid opcodes**: Unknown opcode values in rules
- **Circular references**: Variables referencing themselves

## Security Considerations

- **File validation**: Always validate header and section boundaries
- **Buffer overflows**: Check string lengths before reading
- **Resource limits**: Limit maximum file size and rule counts
- **Malformed data**: Handle invalid Unicode sequences gracefully

## Compatibility

The KM2 format maintains backward compatibility:

- Version 1.5 readers can load 1.3 and 1.4 files
- Missing sections are treated as empty
- Unknown options default to safe values
- Invalid data is rejected with error messages